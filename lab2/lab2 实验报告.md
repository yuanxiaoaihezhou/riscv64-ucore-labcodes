# lab2 物理内存和页表

## 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合kern/mm/default_pmm.c中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。 请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 你的first fit算法是否有进一步的改进空间？

## Answer
default_pmm.c 实现了基于**首次适配算法（First-Fit Memory Allocation, FFMA）** 的物理内存管理器。首次适配算法的思想是在内存请求时，从头开始查找第一个足够大的空闲块来分配。如果找到的块远大于请求的大小，则将其分割，多余部分继续保持空闲。这一实现通过**双向链表**管理内存块，并提供了内存分配、释放等操作接口。
### 关键结构与变量
- **free_area：** free_area 是用于管理空闲内存块的结构体，包含 free_list 和 nr_free。
  - free_list：空闲页块的链表，记录系统中所有可用的内存块。
  - nr_free：系统中当前空闲页的数量。
- **list_entry_t：** 用于实现双向链表的结构体。
### 初始化函数 default_init
功能：初始化内存管理器。初始化空闲页链表，开始为空。并且设置初始的空闲页数量为 0。
作用：为后续管理空闲页块打下基础。
### 内存映射初始化 default_init_memmap
功能：初始化 base 开始的 n 个页块。
- 初始化每个页：
  - 清空页的 flags 和 property，将引用计数 ref 设置为 0。
  - 将 base->property 设置为 n，表示这个块有 n 个页。
  - 更新空闲页数量 nr_free。
- 插入到空闲链表：
  - 将新的页块**按地址顺序**插入到空闲页链表 free_list 中。
作用：将物理内存划分为空闲块并加入到空闲链表中，便于后续管理。
### 分配页函数 default_alloc_pages
功能：分配 n 个连续的物理页。
- 从 free_list 中找到第一个可以容纳 n 个页的空闲块。
- 找到后，如果块的大小大于 n，则将块分为两部分：前 n 页分配给请求，剩余部分继续作为空闲块。
- 更新空闲页数量 nr_free，并返回找到的页块。
作用：实现 First Fit 算法，分配满足请求的内存块，并对空闲链表进行相应调整。
### 释放页函数 default_free_pages
功能：释放 n 个页块，将它们重新插入空闲链表。
- 初始化每个页的属性。
- 将释放的页块插入到 free_list 中，并保持链表的有序性。
- 尝试合并相邻的空闲块，以避免内存碎片化。包括前向检查（base的前面有没有相邻的块）和后向检查（base的后有没有相邻的块）。
作用：释放内存并将相邻的空闲块进行合并，减少内存碎片。
### 空闲页数量 default_nr_free_pages
功能：返回系统当前空闲页的数量，即nr_free。
### 检查函数 basic_check 和 default_check
basic_check 和 default_check 用于测试内存分配和释放是否正确。
- basic_check 进行基础的内存分配、释放测试，确保分配、释放操作的正确性。
- default_check 在 basic_check 的基础上，进行更复杂的测试，包括分配多个页块、释放页块、检查页块合并等。
### 内存管理器 default_pmm_manager
功能：定义了基于**首次适配算法**的物理内存管理器，包含了**内存初始化、分配、释放和检查等**操作函数。
通过这个结构体，pmm**机制**可以使用首次适配的内存管理**策略**来分配和管理物理内存。
### 程序在进行物理内存分配的过程
1. 内存初始化：系统在启动过程中，会调用内存管理器初始化函数来准备空闲内存的管理数据结构。这个步骤是通过 default_init 和 default_init_memmap 函数实现的。
2. 内存分配请求处理：当系统需要分配物理内存时，会调用 default_alloc_pages 函数，在空闲内存链表中找到第一个足够大的空闲块，分配给请求者。
3. 内存释放和合并：当内存不再需要时，通过 default_free_pages 函数将其释放回空闲链表，并尝试将相邻的空闲块合并，以减少内存碎片。
### First Fit 算法的改进空间
First Fit 算法虽然简单直观，但在实际应用中存在一些不足，改进 First Fit 算法的核心目标在于**减少碎片化** 和 **提高查找效率**，可以考虑从如下几个方面进行改进：
1. 减少内存碎片：
由于 First Fit 每次从链表头开始查找第一个合适的块进行分配，可能会在链表前端留下很多较小的空闲块，导致外部碎片增加。
以考虑使用 Best Fit 或 Next Fit 算法，Best Fit 通过寻找最合适的块来减少碎片，而 Next Fit 则通过从上次分配结束的位置继续查找来减少前端碎片。
1. 提高查找效率：
当前实现的查找效率是线性的 O(n)，当内存块数量较多时，查找时间较长。可以考虑将 空闲块链表改为平衡树，如 AVL 树或红黑树，以提高查找效率。
跳表 也是一个可以考虑的数据结构，它能够在保持链表灵活性的同时提供更快的查找速度。
1. 分离不同大小的空闲块：
目前所有的空闲块都保存在一个链表中，这意味着不论请求大小如何，都需要遍历整个链表。可以考虑使用 分离空闲链表（Segregated Free List），将不同大小的块分别存储，以加速查找和分配过程。
1. 考虑改用伙伴系统（Buddy System）
伙伴系统 是一种将内存按 2 的幂次划分的方法，它能够高效地合并和分割内存块，减少碎片化问题。虽然这种方法有时会造成内存对齐浪费，但对于减少碎片和管理效率而言，是一种不错的改进。
1. 合并策略优化：
当前的合并策略是每次释放时尝试合并相邻的空闲块，这可能会带来一定的性能开销。可以考虑采用**延迟合并策略**，即在内存紧张且没有合适的空闲块时再进行合并，以减少释放时的性能影响。
### 总结
default_pmm.c 实现了基于**首次适配算法**的物理内存管理器。该文件提供了**初始化、分配、释放和检查内存**的接口。空闲页块通过**双向链表 free_list**管理，以实现动态内存分配的灵活性。首次适配算法简单高效，但可能会导致**内存碎片化**问题。