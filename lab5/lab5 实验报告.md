# lab5:用户程序

## 练习1: 加载应用程序并执行（需要编码）
do_execv函数调用`load_icode`（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充`load_icode`的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好`proc_struct`结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

请在实验报告中简要说明你的设计实现过程。

- 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

## 练习2: 父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数`do_fork`在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过`copy_range`函数（位于kern/mm/pmm.c中）实现的，请补充`copy_range`的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

- 如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。
> Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。

## Answer：
### 实现过程
```c++
// 获取源页面所在的虚拟地址（注意，此时的PDT是内核状态下的页目录表）
void * kva_src=page2kva(page);
// 获取目标页面所在的虚拟地址
void * kva_dst=page2kva(npage);
// 页面数据复制
memcpy(kva_dst,kva_src,PGSIZE);
//将该页面设置至对应的PTE中
ret = page_insert(to, npage, start, perm);
```
我们在`do_fork()`中调用`copy_mm()`，该函数会根据`clone_flags`来确定是否需要克隆使用当前进程的进程管理结构。如果不需要，我们新建一个新的mm结构体并设置其中的页表基地址。我们对`oldmm`上锁，之后进入`dup_mmap(mm, oldmm)`。

在`dup_mmap(mm, oldmm)`中，我们循环把双向链表上的每一块VMA卸下并创造同一范围内的nvma挂到新的`mmstruct`，随后进入`cpoy_range()`。

在`copy_range()`中，我们从`start`开始在`from`页表上找页表项，在`to`页表上同样找页表项，如果没有找到则创建一个新的页表项。我们找到from页表项指向的物理页（page结构体），然后分配一个页结构体给进程B，获取两个页结构体管理的页的实际虚拟地址后把from页的内容复制到to页的内容中，最后把页和页表项关联起来，并通过perm设置其权限。

### COW的概要设计
当一个用户父进程创建子进程时，父进程会将申请的用户内存空间设置为只读状态，而子进程则可以共享父进程的用户内存空间中的页面。当父进程或子进程尝试修改此用户内存空间中的某页面时，系统能够通过`page fault`异常机制检测到这一操作，并自动进行内存页面的拷贝。这一过程确保了两个进程各自拥有独立的内存页面，从而使得一个进程对内存的修改不会影响到另一个进程。

- **页目录表的拷贝**：在执行`do_fork`时，子进程的页目录表会直接拷贝自父进程的页目录表。在`dup_mmap`过程中，只需保留拷贝虚拟内存区域（VMA）链表的部分，而无需调用`copy_range`来为子进程分配新的物理内存。

- **内存页面的共享**：父进程的内存空间对应的所有Page结构的引用计数（ref）均会加1，以表明子进程也在使用这些内存页面。

- **写权限的控制**：父子进程的页目录表的写权限会被取消。当父进程或子进程尝试执行写操作时，将触发页面访问异常。系统随后会进入页面访问异常处理函数，在该函数中进行内存拷贝，并恢复页目录表的写权限，确保两个进程的内存空间独立且互不影响。

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：

请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）
执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-1.0.1）

## Challenge：实现 Copy on Write （COW）机制

给出实现源码,测试用例和设计报告（包括在cow情况下的各种状态转换（类似有限状态自动机）的说明）。

这个扩展练习涉及到本实验和上一个实验“虚拟内存管理”。在ucore操作系统中，当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。请在ucore中实现这样的COW机制。

## Challenge：说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？